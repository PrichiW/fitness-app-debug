# Тестовое задание: FitnessApp

Простое Android-приложение для просмотра списка тренировок, реализованное в рамках тестового задания.

## Скриншоты

| Экран списка | Экран плеера |
| :---: | :---: |
| ![Workout List](<img width="476" height="790" alt="image" src="https://github.com/user-attachments/assets/382f399d-c1e7-4c1d-853d-4e318374710c" />
 | ![Video Player](<img width="476" height="791" alt="image" src="https://github.com/user-attachments/assets/24025d69-f862-46c6-a9a8-9f7604272d78" />
 |

## Установка

Готовый APK-файл можно скачать из раздела [Releases]([link_to_your_releases_page](https://github.com/PrichiW/fitness-app-debug/releases)) на GitHub.

## Функционал

*   **Экран списка тренировок:**
    *   Отображение списка тренировок, полученных по сети.
    *   Поиск по названию тренировки.
    *   Фильтрация по типу тренировки (Кардио, Силовые и т.д.).
    *   Обработка состояний загрузки, ошибки и пустого списка.
*   **Экран видеоплеера:**
    *   Воспроизведение видео тренировки с использованием ExoPlayer.
    *   Кастомный UI контроллер с возможностью:
        *   Изменения скорости воспроизведения (от 0.5x до 2.0x).
        *   Перехода в полноэкранный режим и обратно.
    *   Отображение детальной информации о тренировке.

## Архитектура и технические решения

Приложение построено на основе принципов **Clean Architecture** с разделением на три основных слоя: `data`, `domain` и `presentation`. Архитектурный паттерн — **MVVM**.

*   **`presentation` (UI Layer):**
    *   **UI:** View-based (XML) с использованием ViewBinding.
    *   **Навигация:** Jetpack Navigation Component (Single-Activity).
    *   **State Management:** `ViewModel` + `LiveData` для управления состоянием. UI-состояния моделируются через `sealed class` (`UiState`).
    *   **Асинхронность:** Kotlin Coroutines (`viewModelScope`).
    *   **Видео:** `ExoPlayer (Media3)` для воспроизведения видео.

*   **`domain` (Business Logic Layer):**
    *   Не зависит от других слоев. Содержит "чистую" бизнес-логику.
    *   **UseCases:** Каждый сценарий использования вынесен в отдельный класс (`GetWorkoutsUseCase`, `SearchWorkoutsUseCase` и т.д.).
    *   **Модели:** "Чистые" Kotlin `data class`'ы.
    *   **Репозиторий (интерфейс):** Абстракция над источником данных.

*   **`data` (Data Layer):**
    *   **Работа с сетью:** `Retrofit` для декларативного описания API и `OkHttp` для выполнения запросов.
    *   **Парсинг JSON:** `Gson`.
    *   **Обработка ошибок:** Использован `Result` wrapper для безопасной передачи данных и ошибок из `data` слоя в `domain`.
    *   **Мапперы:** Для преобразования DTO-моделей из сети в доменные модели.

*   **Dependency Injection:**
    *   **Hilt** используется для предоставления зависимостей во все слои приложения.

### Особенности реализации и замеченные проблемы

#### 1. Управление полноэкранным режимом
Реализован надежный механизм входа и выхода из полноэкранного режима, который корректно обрабатывает смену ориентации, системную кнопку "Назад" (`OnBackPressedCallback`) и не "ломает" UI родительской Activity. Для устранения **визуальных артефактов (отступов)** после выхода из полноэкранного режима, связанных с таймингами перестроения `ConstraintLayout` при смене ориентации, динамическое изменение `LayoutParams` контейнера плеера выполняется асинхронно, с помощью `View.post { ... }`.
#### 2. Смена качества видео
Предоставленный API отдает ссылки на `.mp4` файлы, которые не поддерживают адаптивное вещание (HLS/DASH). В связи с этим, реализована "заглушка" для UI: кнопка настроек открывает диалог выбора качества, демонстрируя готовность UI к этой функции. Для полноценной реализации необходимо, чтобы бэкенд предоставлял видео в соответствующем формате.

#### 3. Несоответствие данных от API
В ходе тестирования было замечено, что метаданные длительности тренировки (например, "20 минут") не всегда соответствуют реальной длительности видеофайла. Приложение корректно отображает данные так, как их предоставляет API.
